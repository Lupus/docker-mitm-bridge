{{- if .Values.ca.generate }}
apiVersion: batch/v1
kind: Job
metadata:
  name: {{ .Release.Name }}-cert-generator
  namespace: {{ .Values.namespace }}
  annotations:
    "helm.sh/hook": post-install,post-upgrade
    "helm.sh/hook-weight": "1"
    "helm.sh/hook-delete-policy": before-hook-creation
spec:
  template:
    metadata:
      name: cert-generator
    spec:
      serviceAccountName: {{ .Release.Name }}-cert-generator
      restartPolicy: Never
      containers:
      - name: cert-generator
        image: alpine:latest
        command:
        - /bin/sh
        - -c
        - |
          set -e

          # Install required tools
          apk add --no-cache curl openssl kubectl

          # Install cfssl
          curl -L https://github.com/cloudflare/cfssl/releases/download/v1.6.4/cfssl_1.6.4_linux_amd64 -o /usr/local/bin/cfssl
          curl -L https://github.com/cloudflare/cfssl/releases/download/v1.6.4/cfssljson_1.6.4_linux_amd64 -o /usr/local/bin/cfssljson
          chmod +x /usr/local/bin/cfssl /usr/local/bin/cfssljson

          # Create working directory
          mkdir -p /work/ca /work/certs
          cd /work

          # Check if CA already exists
          if kubectl get secret -n {{ .Values.namespace }} {{ .Release.Name }}-ca 2>/dev/null; then
            echo "CA already exists, retrieving..."
            kubectl get secret -n {{ .Values.namespace }} {{ .Release.Name }}-ca -o jsonpath='{.data.tls\.crt}' | base64 -d > /work/ca/ca.crt
            kubectl get secret -n {{ .Values.namespace }} {{ .Release.Name }}-ca -o jsonpath='{.data.tls\.key}' | base64 -d > /work/ca/ca.key
          else
            echo "Generating new CA..."

            # Create CA configuration
            cat > ca-csr.json <<EOF
          {
            "CN": "{{ .Values.ca.subject.commonName }}",
            "key": {
              "algo": "rsa",
              "size": 2048
            },
            "names": [{
              "C": "{{ .Values.ca.subject.country }}",
              "ST": "{{ .Values.ca.subject.state }}",
              "O": "{{ .Values.ca.subject.organization }}"
            }]
          }
          EOF

            # Generate CA
            /usr/local/bin/cfssl gencert -initca ca-csr.json | /usr/local/bin/cfssljson -bare ca
            mv ca.pem /work/ca/ca.crt
            mv ca-key.pem /work/ca/ca.key

            # Store CA in secret
            kubectl create secret tls {{ .Release.Name }}-ca \
              --cert=/work/ca/ca.crt \
              --key=/work/ca/ca.key \
              -n {{ .Values.namespace }} || true
          fi

          # Create CA bundle ConfigMap for pod injection
          kubectl create configmap {{ .Release.Name }}-ca-bundle \
            --from-file=ca.crt=/work/ca/ca.crt \
            -n {{ .Values.namespace }} \
            --dry-run=client -o yaml | kubectl apply -f -

          # CFSSL config for signing
          cat > cfssl-config.json <<EOF
          {
            "signing": {
              "default": {
                "expiry": "{{ .Values.certificates.duration }}"
              },
              "profiles": {
                "server": {
                  "usages": ["signing", "key encipherment", "server auth", "client auth"],
                  "expiry": "{{ .Values.certificates.duration }}"
                }
              }
            }
          }
          EOF

          # Generate certificates for each configured domain
          {{- range $group, $config := .Values.interceptDomains }}
          {{- if $config.enabled }}
          {{- range $domain := $config.domains }}

          echo "Generating certificate for {{ $domain }}..."

          # Sanitize domain name for secret name
          DOMAIN_SANITIZED=$(echo "{{ $domain }}" | sed 's/\*/-wildcard-/g' | sed 's/\./-/g')

          # Check if certificate already exists
          if kubectl get secret -n {{ $.Values.namespace }} {{ $.Release.Name }}-cert-${DOMAIN_SANITIZED} 2>/dev/null; then
            echo "Certificate for {{ $domain }} already exists, skipping..."
          else
            # Create certificate request
            cat > cert-{{ $domain }}-csr.json <<EOF
          {
            "CN": "{{ $domain }}",
            "hosts": ["{{ $domain }}"],
            "key": {
              "algo": "rsa",
              "size": 2048
            },
            "names": [{
              "C": "{{ $.Values.ca.subject.country }}",
              "ST": "{{ $.Values.ca.subject.state }}",
              "O": "{{ $.Values.ca.subject.organization }}"
            }]
          }
          EOF

            # Generate certificate
            /usr/local/bin/cfssl gencert \
              -ca=/work/ca/ca.crt \
              -ca-key=/work/ca/ca.key \
              -config=cfssl-config.json \
              -profile=server \
              cert-{{ $domain }}-csr.json | /usr/local/bin/cfssljson -bare cert-{{ $domain }}

            # Create secret for the certificate
            kubectl create secret tls {{ $.Release.Name }}-cert-${DOMAIN_SANITIZED} \
              --cert=cert-{{ $domain }}.pem \
              --key=cert-{{ $domain }}-key.pem \
              -n {{ $.Values.namespace }}
          fi

          {{- end }}
          {{- end }}
          {{- end }}

          echo "Certificate generation completed successfully!"
        volumeMounts:
        - name: work
          mountPath: /work
      volumes:
      - name: work
        emptyDir: {}
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: {{ .Release.Name }}-cert-generator
  namespace: {{ .Values.namespace }}
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: {{ .Release.Name }}-cert-generator
  namespace: {{ .Values.namespace }}
rules:
- apiGroups: [""]
  resources: ["secrets"]
  verbs: ["create", "get", "list", "update", "patch"]
- apiGroups: [""]
  resources: ["configmaps"]
  verbs: ["create", "get", "list", "update", "patch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: {{ .Release.Name }}-cert-generator
  namespace: {{ .Values.namespace }}
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: {{ .Release.Name }}-cert-generator
subjects:
- kind: ServiceAccount
  name: {{ .Release.Name }}-cert-generator
  namespace: {{ .Values.namespace }}
{{- end }}