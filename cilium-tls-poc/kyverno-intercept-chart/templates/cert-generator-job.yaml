{{- if .Values.ca.generate }}
apiVersion: batch/v1
kind: Job
metadata:
  name: {{ .Release.Name }}-cert-generator
  namespace: {{ .Values.namespace }}
  annotations:
    "helm.sh/hook": post-install,post-upgrade
    "helm.sh/hook-weight": "1"
    "helm.sh/hook-delete-policy": before-hook-creation
spec:
  template:
    metadata:
      name: cert-generator
    spec:
      serviceAccountName: {{ .Release.Name }}-cert-generator
      restartPolicy: Never
      containers:
      - name: cert-generator
        image: alpine:latest
        command:
        - /bin/sh
        - -c
        - |
          set -e

          # Install required tools
          apk add --no-cache curl openssl kubectl

          # Install cfssl
          curl -L https://github.com/cloudflare/cfssl/releases/download/v1.6.4/cfssl_1.6.4_linux_amd64 -o /usr/local/bin/cfssl
          curl -L https://github.com/cloudflare/cfssl/releases/download/v1.6.4/cfssljson_1.6.4_linux_amd64 -o /usr/local/bin/cfssljson
          chmod +x /usr/local/bin/cfssl /usr/local/bin/cfssljson

          # Create working directory
          mkdir -p /work/ca /work/certs
          cd /work

          # Check if CA already exists
          if kubectl get secret -n {{ .Values.namespace }} {{ .Release.Name }}-ca 2>/dev/null; then
            echo "CA already exists, retrieving..."
            kubectl get secret -n {{ .Values.namespace }} {{ .Release.Name }}-ca -o jsonpath='{.data.tls\.crt}' | base64 -d > /work/ca/ca.crt
            kubectl get secret -n {{ .Values.namespace }} {{ .Release.Name }}-ca -o jsonpath='{.data.tls\.key}' | base64 -d > /work/ca/ca.key
          else
            echo "Generating new CA..."

            # Create CA configuration
            cat > ca-csr.json <<EOF
          {
            "CN": "{{ .Values.ca.subject.commonName }}",
            "key": {
              "algo": "rsa",
              "size": 2048
            },
            "names": [{
              "C": "{{ .Values.ca.subject.country }}",
              "ST": "{{ .Values.ca.subject.state }}",
              "O": "{{ .Values.ca.subject.organization }}"
            }]
          }
          EOF

            # Generate CA
            /usr/local/bin/cfssl gencert -initca ca-csr.json | /usr/local/bin/cfssljson -bare ca
            mv ca.pem /work/ca/ca.crt
            mv ca-key.pem /work/ca/ca.key

            # Store CA in secret
            kubectl create secret tls {{ .Release.Name }}-ca \
              --cert=/work/ca/ca.crt \
              --key=/work/ca/ca.key \
              -n {{ .Values.namespace }} || true
          fi

          echo "CA generation completed successfully!"
          echo "Domain-specific certificates will be generated dynamically by the xDS service."
        volumeMounts:
        - name: work
          mountPath: /work
      volumes:
      - name: work
        emptyDir: {}
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: {{ .Release.Name }}-cert-generator
  namespace: {{ .Values.namespace }}
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: {{ .Release.Name }}-cert-generator
  namespace: {{ .Values.namespace }}
rules:
- apiGroups: [""]
  resources: ["secrets"]
  verbs: ["create", "get", "list", "update", "patch"]
- apiGroups: [""]
  resources: ["configmaps"]
  verbs: ["create", "get", "list", "update", "patch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: {{ .Release.Name }}-cert-generator
  namespace: {{ .Values.namespace }}
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: {{ .Release.Name }}-cert-generator
subjects:
- kind: ServiceAccount
  name: {{ .Release.Name }}-cert-generator
  namespace: {{ .Values.namespace }}
{{- end }}